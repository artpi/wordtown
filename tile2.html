<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Isometric Grid with Phaser</title>
    <!-- Load Phaser from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,          // Automatically choose WebGL or Canvas
            width: 1440,                // Canvas width
            height: 768,                // Canvas height
            backgroundColor: '#00ff00', // Vibrant green background like the grassy field
            scene: {
                preload: preload,       // Preload function for assets
                create: create,         // Create function for grid and tiles
                update: update          // Update function for controls
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            }
        };

        // Initialize the game
        const game = new Phaser.Game(config);

        // Global variables for controls
        let cursors;
        let controlConfig = {
            camera: null,
            zoomIn: null,
            zoomOut: null,
            dragSpeed: 1,
            zoomSpeed: 0.05,
            minZoom: 0.5,
            maxZoom: 2
        };

        // Preload function (for loading tile assets later)
        function preload() {
            // Example: Load your output tiles here when ready
            this.load.image('tile0', '/tiles/output_0.png');
            this.load.image('tile1', '/tiles/output_1.png');
            this.load.image('tile2', '/tiles/output_2.png');
            this.load.image('tile3', '/tiles/output_3.png');
            this.load.image('tile4', '/tiles/output_4.png');
            this.load.image('tile5', '/tiles/output_5.png');
            this.load.image('tile6', '/tiles/output_6.png');
            this.load.image('tile7', '/tiles/output_7.png');
            this.load.image('tile8', '/tiles/output_8.png');
        }

        // Create function to draw the grid and prepare for tiles
        function create() {
            // Grid parameters
            const tileWidth = 412;      // Desired screen width of each tile
            const tileHeight = tileWidth / 2;      // Desired screen height of each tile
            const gridSize = 4;         // 4x4 grid
            
            // Calculate the total width and height of the isometric grid
            const gridWidthPx = gridSize * tileWidth;
            const gridHeightPx = gridSize * tileHeight;
            
            // Calculate center offsets based on canvas dimensions
            const offsetX = ( gridWidthPx) / 4 + tileWidth/2;
            const offsetY = (this.sys.game.config.height - gridHeightPx) / 2;

            // Create a container for all game objects to enable group scrolling
            this.gameContainer = this.add.container(0, 0);

            // Create graphics object for drawing grid lines
            const graphics = this.add.graphics();
            this.gameContainer.add(graphics);
            graphics.lineStyle(1, 0x000000, 1); // Black lines, 1px thick

            // // Draw vertical grid lines (constant gridX)
            // for (let gridX = 0; gridX <= gridSize; gridX++) {
            //     const x1 = (gridX - 0) * (tileWidth / 2) + offsetX;
            //     const y1 = (gridX + 0) * (tileHeight / 2) + offsetY;
            //     const x2 = (gridX - (gridSize - 1)) * (tileWidth / 2) + offsetX;
            //     const y2 = (gridX + (gridSize - 1)) * (tileHeight / 2) + offsetY;
            //     graphics.lineBetween(x1, y1, x2, y2);
            // }

            // // Draw horizontal grid lines (constant gridY)
            // for (let gridY = 0; gridY <= gridSize; gridY++) {
            //     const x1 = (0 - gridY) * (tileWidth / 2) + offsetX;
            //     const y1 = (0 + gridY) * (tileHeight / 2) + offsetY;
            //     const x2 = ((gridSize - 1) - gridY) * (tileWidth / 2) + offsetX;
            //     const y2 = ((gridSize - 1) + gridY) * (tileHeight / 2) + offsetY;
            //     graphics.lineBetween(x1, y1, x2, y2);
            // }

            // Calculate scale factor (assuming all tiles have the same original size)
            const desiredWidth = tileWidth;
            const originalWidth = this.textures.get('tile0').source[0].width;
            const scale = desiredWidth / (originalWidth - 200);

            // Function to place tiles at grid coordinates
            const placeTile = (gridX, gridY, tileKey) => {
                const screenX = (gridX - gridY) * (tileWidth / 2) + offsetX;
                const screenY = (gridX + gridY) * (tileHeight / 2) + offsetY;
                const tile = this.add.image(screenX, screenY, tileKey)
                    .setScale(scale);
                this.gameContainer.add(tile);
                return tile;
            };
            
            // Place tiles
            placeTile(1, 1, 'tile0');
            placeTile(1, 2, 'tile1');
            placeTile(2, 1, 'tile2');
            placeTile(2, 2, 'tile3');
            placeTile(3, 1, 'tile4');
            placeTile(3, 2, 'tile5');
            placeTile(3, 3, 'tile6');
            placeTile(2, 3, 'tile7');
            placeTile(1, 3, 'tile8');

            // Set up camera controls
            controlConfig.camera = this.cameras.main;
            
            // Set camera bounds (adjust these values based on your grid size)
            const worldWidth = gridWidthPx * 2;
            const worldHeight = gridHeightPx * 2;
            this.cameras.main.setBounds(-worldWidth/2, -worldHeight/2, worldWidth, worldHeight);
            
            // Center the camera on the grid initially
            this.cameras.main.centerOn(offsetX, offsetY);

            // Set up keyboard controls
            cursors = this.input.keyboard.createCursorKeys();
            controlConfig.zoomIn = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);
            controlConfig.zoomOut = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

            // Enable mouse/touch drag for camera movement
            this.input.on('pointermove', function (pointer) {
                if (pointer.isDown) {
                    this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
                    this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
                }
            }, this);

            // Enable mouse wheel zoom
            this.input.on('wheel', function (pointer, gameObjects, deltaX, deltaY, deltaZ) {
                const zoom = this.cameras.main.zoom;
                if (deltaY > 0) {
                    // Zoom out
                    this.cameras.main.zoom = Math.max(controlConfig.minZoom, zoom - controlConfig.zoomSpeed);
                } else {
                    // Zoom in
                    this.cameras.main.zoom = Math.min(controlConfig.maxZoom, zoom + controlConfig.zoomSpeed);
                }
            }, this);

            // Add instructions text
            this.add.text(10, 10, 'Arrow Keys: Move | Q/E: Zoom | Mouse Drag: Pan | Mouse Wheel: Zoom', {
                font: '16px Arial',
                fill: '#000000',
                backgroundColor: '#ffffff'
            }).setScrollFactor(0).setDepth(100);
        }

        // Update function for controls
        function update() {
            // Keyboard camera movement
            const camera = controlConfig.camera;
            const speed = 10;

            if (cursors.left.isDown) {
                camera.scrollX -= speed / camera.zoom;
            } else if (cursors.right.isDown) {
                camera.scrollX += speed / camera.zoom;
            }

            if (cursors.up.isDown) {
                camera.scrollY -= speed / camera.zoom;
            } else if (cursors.down.isDown) {
                camera.scrollY += speed / camera.zoom;
            }

            // Keyboard zoom controls
            if (controlConfig.zoomIn.isDown) {
                camera.zoom = Math.min(controlConfig.maxZoom, camera.zoom + controlConfig.zoomSpeed);
            } else if (controlConfig.zoomOut.isDown) {
                camera.zoom = Math.max(controlConfig.minZoom, camera.zoom - controlConfig.zoomSpeed);
            }
        }
    </script>
</body>
</html>