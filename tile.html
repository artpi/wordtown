<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Tile Grid with Pixi.js (2x4 Grid)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.1/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        // Constants
        const tileWidth = 1024;  // Width of each tile
        const tileHeight = 512;  // Height of each tile
        const tileOffset = 20;   // Reduced offset for tighter spacing
        const gridWidth = 4;     // 4 tiles horizontally
        const gridHeight = 2;    // 2 rows
        const debugMode = true;  // Enable debug mode to see what's happening
        const scaleFactor = 0.5;  // Smaller scale to fit everything better
        const isometricAngle = 26.57; // Standard isometric angle in degrees
        const showMasks = true;  // Set to true to visualize the masks for debugging
        const useMasking = false;  // Set to false to disable masking completely
        const displayMode = 'tiles-only'; // Options: 'tiles-only', 'tiles-with-backgrounds', 'colored-boxes', 'debug-only'
        const tileSpacing = 1.0;  // Full tile dimensions
        
        // Precise measurements for visible content positioning
        const marginSize = 100;  // 100px transparent margin on each side
        const visibleWidth = tileWidth - (marginSize * 2);  // 824px
        const visibleHeight = tileHeight - (marginSize * 2);  // 312px
        const visibleWidthRatio = visibleWidth / tileWidth;  // 0.8046875
        const visibleHeightRatio = visibleHeight / tileHeight;  // 0.609375
        
        // Fine-tuned overlap factor for proper alignment
        const overlapFactor = 0.2;  // Adjusted for perfect alignment of visible parts

        // Variables
        let app;
        let container;
        let tiles = [];
        let maskTexture;
        let invertedMaskTexture; // We'll store the inverted mask here
        let resourcesLoaded = false;

        // Initialize PixiJS application
        function initApp() {
            // Create a canvas that fits on screen
            const canvasWidth = Math.min(window.innerWidth * 0.9, gridWidth * tileWidth * scaleFactor * 1.5);
            const canvasHeight = Math.min(window.innerHeight * 0.9, gridHeight * tileHeight * scaleFactor * 1.5);
            
            console.log(`Creating canvas: ${canvasWidth} x ${canvasHeight}`);
            
            // Create PixiJS application
            app = new PIXI.Application({
                width: canvasWidth,
                height: canvasHeight,
                backgroundColor: 0x323232, // Dark gray background
                antialias: true
            });
            
            document.body.appendChild(app.view);
            
            // Create a container for all tiles and grid elements
            container = new PIXI.Container();
            app.stage.addChild(container);
            
            // Position the container in the center of the screen
            container.position.set(app.screen.width / 2, app.screen.height / 2);
            
            // Load resources
            loadResources();
        }

        // Load all image resources
        function loadResources() {
            // Create an array to hold the asset objects
            const assets = [];
            
            // Add tile images to load
            for (let i = 1; i <= 8; i++) {
                assets.push({ name: `tile${i}`, url: `tiles/output_${i}.png` });
            }
            
            // Add mask image
            assets.push({ name: 'mask', url: 'tiles/processed_mask.png' });
            
            // Use Pixi's Assets class to load everything
            PIXI.Assets.load(assets.map(asset => asset.url)).then((resources) => {
                console.log('All resources loaded');
                
                // Store loaded textures
                for (let i = 1; i <= 8; i++) {
                    tiles[i-1] = resources[`tiles/output_${i}.png`];
                }
                
                maskTexture = resources['tiles/processed_mask.png'];
                
                // Create inverted mask
                invertedMaskTexture = invertMask(maskTexture);
                
                resourcesLoaded = true;
                
                console.log(`Loaded ${tiles.filter(t => t).length} tiles`);
                console.log(`Mask loaded: ${maskTexture !== undefined}`);
                
                // Start drawing when resources are loaded
                createIsometricGrid();
            }).catch((error) => {
                console.error('Error loading resources:', error);
            });
        }

        // Function to invert a mask texture
        function invertMask(originalMask) {
            // Create a render texture the same size as the original mask
            const renderer = app.renderer;
            const renderTexture = PIXI.RenderTexture.create({
                width: originalMask.width,
                height: originalMask.height
            });
            
            // Create a sprite with the original mask
            const sprite = new PIXI.Sprite(originalMask);
            
            // Invert the colors (1 - color)
            const colorMatrix = new PIXI.filters.ColorMatrixFilter();
            colorMatrix.negative(true); // This inverts the colors
            sprite.filters = [colorMatrix];
            
            // Render the inverted sprite to the render texture
            renderer.render(sprite, { renderTexture });
            
            console.log("Created inverted mask");
            return renderTexture;
        }

        // Create and draw the isometric grid
        function createIsometricGrid() {
            if (!resourcesLoaded) return;
            
            // Draw a reference grid in debug mode
            if (debugMode) {
                const grid = new PIXI.Graphics();
                grid.lineStyle(2, 0xFF0000);
                grid.moveTo(-app.screen.width/2, 0);
                grid.lineTo(app.screen.width/2, 0);
                grid.moveTo(0, -app.screen.height/2);
                grid.lineTo(0, app.screen.height/2);
                container.addChild(grid);
                
                // Draw a point at the center
                const centerPoint = new PIXI.Graphics();
                centerPoint.beginFill(0x00FF00);
                centerPoint.drawCircle(0, 0, 5);
                centerPoint.endFill();
                container.addChild(centerPoint);
            }
            
            // Create a container for the isometric grid
            const gridContainer = new PIXI.Container();
            container.addChild(gridContainer);
            
            // Apply scale to fit on screen
            gridContainer.scale.set(scaleFactor);
            
            // Rotate the entire grid for isometric view
            gridContainer.angle = isometricAngle;
            
            // Calculate the total width and height of the grid in pixels
            const gridWidthPx = gridWidth * tileWidth * tileSpacing;
            const gridHeightPx = gridHeight * tileHeight * tileSpacing;
            
            // Position the grid in the center
            gridContainer.position.set(0, 0);
            
            if (debugMode) {
                // Draw a point at the grid origin
                const originPoint = new PIXI.Graphics();
                originPoint.beginFill(0x0000FF);
                originPoint.drawCircle(0, 0, 5);
                originPoint.endFill();
                gridContainer.addChild(originPoint);
            }
            
            // Create a proper grid layout
            // Define a grid layout with the tiles we want to display
            // This layout creates an isometric pattern where:
            // - Tile 5 is positioned at the top-left of tile 4
            // - Each cell corresponds to a position in the isometric grid
            const grid = [
                [null, null, null, null, null],
                [null, null, 5,    null, null],
                [null, null, null, 4,    null],
                [null, null, null, null, null],
                [null, null, null, null, null]
            ];
            
            // Calculate grid center offsets
            const gridCenterRow = 2;  // Center row (row of the middle of the grid)
            const gridCenterCol = 2;  // Center column (column of the middle of the grid)
            
            // Draw the tiles based on the grid layout
            for (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {
                for (let colIndex = 0; colIndex < grid[rowIndex].length; colIndex++) {
                    const tileIndex = grid[rowIndex][colIndex];
                    
                    // Skip empty grid cells
                    if (tileIndex === null) continue;
                    
                    // Convert grid position to isometric coordinates
                    const col = colIndex - gridCenterCol;
                    const row = rowIndex - gridCenterRow;
                    
                    // Draw the tile at this grid position
                    drawIsometricTile(gridContainer, col, row, tileIndex - 1); // Adjust for 0-based index
                }
            }
        }

        // Draw a single isometric tile
        function drawIsometricTile(parentContainer, col, row, tileIndex) {
            // Create a container for this tile
            const tileContainer = new PIXI.Container();
            parentContainer.addChild(tileContainer);
            
            // Calculate position for isometric grid
            // For isometric grids, we need to stagger the tiles for proper alignment
            
            // Calculate the base position using the overlap factor
            let x = col * tileWidth * overlapFactor;
            let y = row * tileHeight * overlapFactor;
            
            // Adjust for isometric grid - this creates the diamond pattern
            // Shift columns on odd rows to create the staggered effect
            x += (row % 2) * (tileWidth * overlapFactor * 0.5);
            
            // Set the tile position
            tileContainer.position.set(x, y);
            
            if (debugMode) {
                // Draw a point at the tile position
                const tilePoint = new PIXI.Graphics();
                tilePoint.beginFill(0xFFFF00);
                tilePoint.drawCircle(0, 0, 8); // Larger circle for better visibility
                tilePoint.endFill();
                tileContainer.addChild(tilePoint);
                
                // Draw tile outline
                const outline = new PIXI.Graphics();
                outline.lineStyle(2, 0xFFFFFF);
                outline.drawRect(-tileWidth/2, -tileHeight/2, tileWidth, tileHeight);
                tileContainer.addChild(outline);
            }
            
            // Counter-rotate to keep tiles upright
            tileContainer.angle = -isometricAngle;
            
            // Different colored boxes for each tile in debug mode
            const tileColors = [
                0xFF0000, // Red
                0x00FF00, // Green
                0x0000FF, // Blue
                0xFFFF00, // Yellow
                0xFF00FF, // Magenta
                0x00FFFF, // Cyan
                0xFFA500, // Orange
                0x800080  // Purple
            ];
            
            // Draw the tile with mask
            if (tiles[tileIndex]) {
                // Draw a colored background first (only if in correct display mode)
                if (displayMode === 'colored-boxes' || displayMode === 'tiles-with-backgrounds') {
                    const tileBackground = new PIXI.Graphics();
                    tileBackground.beginFill(tileColors[tileIndex]);
                    tileBackground.drawRect(-tileWidth/2, -tileHeight/2, tileWidth, tileHeight);
                    tileBackground.endFill();
                    tileContainer.addChild(tileBackground);
                }
                
                // Add the tile sprite if we're in tiles mode
                if (displayMode === 'tiles-only' || displayMode === 'tiles-with-backgrounds') {
                    // Create a sprite from the tile texture
                    const tileSprite = new PIXI.Sprite(tiles[tileIndex]);
                    tileSprite.anchor.set(0.5);
                    tileSprite.width = tileWidth;
                    tileSprite.height = tileHeight;
                    tileContainer.addChild(tileSprite);
                    
                    console.log(`Added tile sprite ${tileIndex + 1}, texture dimensions: ${tileSprite.width}x${tileSprite.height}`);
                    
                    // Apply masking only if enabled
                    if (useMasking && maskTexture) {
                        // Create a mask sprite - using either original or inverted mask
                        const maskSprite = new PIXI.Sprite(invertedMaskTexture || maskTexture);
                        maskSprite.anchor.set(0.5);
                        
                        // Make mask visible if debug flag is set
                        maskSprite.renderable = showMasks;
                        if (showMasks) {
                            maskSprite.alpha = 0.5; // Semi-transparent for debugging
                        }
                        
                        // Add the mask to the container
                        tileContainer.addChild(maskSprite);
                        
                        // Apply the mask to the tile sprite
                        tileSprite.mask = maskSprite;
                    }
                }
                
                if (debugMode) {
                    // Add tile number for reference
                    const text = new PIXI.Text(`Tile ${tileIndex + 1}`, {
                        fontFamily: 'Arial',
                        fontSize: 60, // Bigger text
                        fill: 0xFFFFFF,
                        align: 'center',
                        stroke: 0x000000, // Black outline
                        strokeThickness: 5 // Thick outline for visibility
                    });
                    text.anchor.set(0.5);
                    tileContainer.addChild(text);
                }
            } else if (debugMode) {
                // Draw placeholder if image is missing
                const placeholder = new PIXI.Graphics();
                placeholder.beginFill(0x6464FF, 0.4);
                placeholder.drawRect(-tileWidth/2, -tileHeight/2, tileWidth, tileHeight);
                placeholder.endFill();
                tileContainer.addChild(placeholder);
                
                const text = new PIXI.Text(`Tile ${tileIndex + 1}`, {
                    fontFamily: 'Arial',
                    fontSize: 60, // Bigger text
                    fill: 0xFFFFFF,
                    align: 'center',
                    stroke: 0x000000, // Black outline
                    strokeThickness: 5 // Thick outline for visibility
                });
                text.anchor.set(0.5);
                tileContainer.addChild(text);
            }
        }

        // Initialize the application
        window.onload = function() {
            initApp();
        };
    </script>
</body>
</html>